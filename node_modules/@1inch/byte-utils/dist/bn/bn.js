"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BN = void 0;
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("../utils");
const validations_1 = require("../validations");
class BN {
    constructor(value) {
        this.value = value;
    }
    static fromNumber(n) {
        return new BN(BigInt(n));
    }
    static fromHex(hex) {
        (0, assert_1.default)((0, validations_1.isHexString)(hex), 'Invalid hex');
        return new BN(BigInt(hex));
    }
    add(other) {
        return new BN(this.value + other.value);
    }
    sub(other) {
        return new BN(this.value - other.value);
    }
    setBit(n, value) {
        if (value) {
            return new BN(this.value | (1n << n));
        }
        return new BN(this.value & ~(1n << n));
    }
    getBit(n) {
        return (this.value & (1n << n)) === 0n ? 0 : 1;
    }
    shiftLeft(n) {
        return new BN(this.value << n);
    }
    shiftRight(n) {
        return new BN(this.value >> n);
    }
    and(other) {
        const raw = typeof other === 'bigint' ? other : other.value;
        return new BN(raw & this.value);
    }
    or(other) {
        const raw = typeof other === 'bigint' ? other : other.value;
        return new BN(raw | this.value);
    }
    xor(other) {
        const raw = typeof other === 'bigint' ? other : other.value;
        return new BN(raw ^ this.value);
    }
    isZero() {
        return this.value === 0n;
    }
    isOne() {
        return this.value === 1n;
    }
    getMask(mask) {
        return this.shiftRight(mask.offset).and(mask.mask);
    }
    setMask(mask, value) {
        const raw = typeof value === 'bigint' ? value : value.value;
        (0, assert_1.default)(raw <= mask.mask, `Value 0x${raw.toString(16)} to big for mask ${mask}`);
        return new BN(this.clearMask(mask).value | (raw << mask.offset));
    }
    clearMask(mask) {
        return new BN(this.value - (mask.toBigInt() & this.value));
    }
    toHex(padNum = 0) {
        return (0, utils_1.add0x)(this.value.toString(16).padStart(padNum, '0'));
    }
    toNumber() {
        return Number(this.value);
    }
}
exports.BN = BN;
//# sourceMappingURL=bn.js.map