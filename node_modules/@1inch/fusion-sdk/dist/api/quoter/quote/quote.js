"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Quote = void 0;
const limit_order_sdk_1 = require("@1inch/limit-order-sdk");
const order_params_1 = require("./order-params");
const types_1 = require("../types");
const preset_1 = require("../preset");
const fusion_order_1 = require("../../../fusion-order");
const sdk_1 = require("../../../sdk");
class Quote {
    constructor(params, response) {
        this.params = params;
        this.fromTokenAmount = BigInt(response.fromTokenAmount);
        this.feeToken = response.feeToken;
        this.presets = {
            [types_1.PresetEnum.fast]: new preset_1.Preset(response.presets.fast),
            [types_1.PresetEnum.medium]: new preset_1.Preset(response.presets.medium),
            [types_1.PresetEnum.slow]: new preset_1.Preset(response.presets.slow),
            [types_1.PresetEnum.custom]: response.presets.custom
                ? new preset_1.Preset(response.presets.custom)
                : undefined
        };
        this.toTokenAmount = response.toTokenAmount;
        this.prices = response.prices;
        this.volume = response.volume;
        this.quoteId = response.quoteId;
        this.whitelist = response.whitelist.map((a) => new limit_order_sdk_1.Address(a));
        this.recommendedPreset = response.recommended_preset;
        this.settlementAddress = new limit_order_sdk_1.Address(response.settlementAddress);
    }
    createFusionOrder(paramsData) {
        const params = order_params_1.FusionOrderParams.new({
            preset: paramsData?.preset || this.recommendedPreset,
            receiver: paramsData?.receiver,
            permit: paramsData?.permit,
            nonce: paramsData?.nonce
        });
        const preset = this.getPreset(params.preset);
        const auctionDetails = preset.createAuctionDetails(params.delayAuctionStartTimeBy);
        return fusion_order_1.FusionOrder.new(this.settlementAddress, {
            makerAsset: this.params.fromTokenAddress,
            takerAsset: this.params.toTokenAddress,
            makingAmount: this.fromTokenAmount,
            takingAmount: preset.auctionEndAmount,
            maker: this.params.walletAddress,
            receiver: params.receiver
        }, {
            auction: auctionDetails,
            fees: {
                integratorFee: {
                    ratio: (0, sdk_1.bpsToRatioFormat)(this.params.fee) || 0n,
                    receiver: paramsData?.takingFeeReceiver
                        ? new limit_order_sdk_1.Address(paramsData?.takingFeeReceiver)
                        : limit_order_sdk_1.Address.ZERO_ADDRESS
                },
                bankFee: preset.bankFee
            },
            whitelist: this.getWhitelist(auctionDetails.startTime, preset.exclusiveResolver)
        }, {
            nonce: params.nonce,
            unwrapWETH: this.params.toTokenAddress.isNative(),
            permit: params.permit
                ? this.params.fromTokenAddress + params.permit.substring(2)
                : undefined,
            allowPartialFills: paramsData?.allowPartialFills ?? preset.allowPartialFills,
            allowMultipleFills: paramsData?.allowMultipleFills ?? preset.allowMultipleFills,
            orderExpirationDelay: paramsData?.orderExpirationDelay
        });
    }
    getPreset(type = types_1.PresetEnum.fast) {
        return this.presets[type];
    }
    getWhitelist(auctionStartTime, exclusiveResolver) {
        if (exclusiveResolver) {
            return this.whitelist.map((resolver) => {
                const isExclusive = resolver.equal(exclusiveResolver);
                return {
                    address: resolver,
                    delay: isExclusive ? 0n : auctionStartTime
                };
            });
        }
        return this.whitelist.map((resolver) => ({
            address: resolver,
            delay: 0n
        }));
    }
}
exports.Quote = Quote;
//# sourceMappingURL=quote.js.map