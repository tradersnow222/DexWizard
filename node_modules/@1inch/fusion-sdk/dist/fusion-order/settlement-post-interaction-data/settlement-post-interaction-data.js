"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SettlementPostInteractionData = void 0;
const ethers_1 = require("ethers");
const limit_order_sdk_1 = require("@1inch/limit-order-sdk");
const assert_1 = __importDefault(require("assert"));
const validations_1 = require("../../validations");
const bytes_iter_1 = require("../../utils/bytes/bytes-iter");
const utils_1 = require("../../utils");
class SettlementPostInteractionData {
    constructor(data) {
        this.whitelist = data.whitelist;
        this.integratorFee = data?.integratorFee;
        this.bankFee = data.bankFee;
        this.auctionStartTime = data.auctionStartTime;
    }
    static new(data) {
        return new SettlementPostInteractionData({
            ...data,
            whitelist: data.whitelist.map((d) => ({
                addressHalf: d.address.toString().slice(-20),
                delay: d.delay
            }))
        });
    }
    static decode(data) {
        (0, assert_1.default)((0, validations_1.isHexBytes)(data), 'Post interaction data must be valid bytes string');
        const iter = new bytes_iter_1.BytesIter(data);
        const feeType = iter.nextByte();
        let bankFee = 0n;
        let integratorFee;
        if ((feeType & 1n) === 1n) {
            bankFee = iter.nextUint32();
        }
        if ((feeType & 2n) === 2n) {
            const integratorAddress = iter.nextUint160();
            const integratorFeeRatio = iter.nextUint32();
            integratorFee = {
                ratio: integratorFeeRatio,
                receiver: limit_order_sdk_1.Address.fromBigInt(integratorAddress)
            };
        }
        const auctionStartTime = iter.nextUint32();
        const whitelist = [];
        while (!iter.isEmpty()) {
            const addressHalf = iter
                .nextBytes(10)
                .toString(16)
                .padStart(20, '0');
            const allowance = iter.nextUint16();
            whitelist.push({
                addressHalf,
                delay: allowance
            });
        }
        return new SettlementPostInteractionData({
            integratorFee,
            bankFee,
            auctionStartTime,
            whitelist
        });
    }
    encode() {
        const fee = {
            type: 'uint8',
            value: 0n
        };
        const data = [fee];
        if (this.bankFee) {
            fee.value |= 1n;
            data.push({
                type: 'uint32',
                value: ethers_1.ethers.solidityPacked(['uint32'], [this.bankFee])
            });
        }
        if (this.integratorFee?.ratio) {
            fee.value |= 2n;
            data.push({
                type: 'uint160',
                value: ethers_1.ethers.solidityPacked(['uint160'], [this.integratorFee.receiver.toString()])
            }, {
                type: 'uint32',
                value: ethers_1.ethers.solidityPacked(['uint32'], [this.integratorFee.ratio])
            });
        }
        data.push({
            type: 'uint32',
            value: this.auctionStartTime
        });
        for (const wl of this.whitelist) {
            data.push({
                type: 'bytes10',
                value: (0, utils_1.add0x)(wl.addressHalf)
            }, {
                type: 'uint16',
                value: BigInt(wl.delay)
            });
        }
        return ethers_1.ethers.solidityPacked(data.map((d) => d.type), data.map((d) => d.value));
    }
}
exports.SettlementPostInteractionData = SettlementPostInteractionData;
//# sourceMappingURL=settlement-post-interaction-data.js.map