"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FusionOrder = void 0;
const limit_order_sdk_1 = require("@1inch/limit-order-sdk");
const assert_1 = __importDefault(require("assert"));
const fusion_extension_1 = require("./fusion-extension");
const auction_details_1 = require("./auction-details");
const settlement_post_interaction_data_1 = require("./settlement-post-interaction-data");
const auction_calculator_1 = require("../auction-calculator");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
class FusionOrder {
    constructor(extensionContract, orderInfo, auctionDetails, postInteractionData, extra = FusionOrder.defaultExtra) {
        const { allowPartialFills, allowMultipleFills, unwrapWETH, enablePermit2, orderExpirationDelay, nonce, permit } = {
            ...FusionOrder.defaultExtra,
            ...extra
        };
        const deadline = auctionDetails.startTime +
            auctionDetails.duration +
            orderExpirationDelay;
        const makerTraits = limit_order_sdk_1.MakerTraits.default()
            .withExpiration(deadline)
            .setPartialFills(allowPartialFills)
            .setMultipleFills(allowMultipleFills);
        if (makerTraits.isBitInvalidatorMode()) {
            (0, assert_1.default)(nonce !== undefined, 'Nonce required, when partial fill or multiple fill disallowed');
        }
        if (unwrapWETH) {
            makerTraits.enableNativeUnwrap();
        }
        if (enablePermit2) {
            makerTraits.enablePermit2();
        }
        if (nonce !== undefined) {
            makerTraits.withNonce(nonce);
        }
        const extension = new fusion_extension_1.FusionExtension(extensionContract, auctionDetails, postInteractionData);
        if (permit) {
            extension.withMakerPermit(orderInfo.makerAsset, permit);
        }
        const builtExtension = extension.build();
        this.inner = new limit_order_sdk_1.LimitOrder({
            ...orderInfo,
            salt: limit_order_sdk_1.LimitOrder.buildSalt(builtExtension, orderInfo.salt)
        }, makerTraits, builtExtension);
        this.fusionExtension = extension;
    }
    get extension() {
        return this.inner.extension;
    }
    static new(settlementExtension, orderInfo, details, extra = FusionOrder.defaultExtra) {
        return new FusionOrder(settlementExtension, orderInfo, details.auction, settlement_post_interaction_data_1.SettlementPostInteractionData.new({
            bankFee: details.fees?.bankFee || 0n,
            integratorFee: details.fees?.integratorFee,
            whitelist: details.whitelist,
            auctionStartTime: details.auction.startTime
        }), extra);
    }
    static fromDataAndExtension(order, extension) {
        const settlementContract = limit_order_sdk_1.Address.fromFirstBytes(extension.makingAmountData);
        (0, assert_1.default)(limit_order_sdk_1.Address.fromFirstBytes(extension.takingAmountData).equal(settlementContract) &&
            limit_order_sdk_1.Address.fromFirstBytes(extension.postInteraction).equal(settlementContract), 'Invalid extension, all calls should be to the same address');
        const makerTraits = new limit_order_sdk_1.MakerTraits(BigInt(order.makerTraits));
        const auctionDetails = auction_details_1.AuctionDetails.decode((0, utils_1.add0x)(extension.makingAmountData.slice(42)));
        const postInteractionData = settlement_post_interaction_data_1.SettlementPostInteractionData.decode((0, utils_1.add0x)(extension.postInteraction.slice(42)));
        const deadline = makerTraits.expiration();
        const orderExpirationDelay = deadline === null
            ? undefined
            : deadline - auctionDetails.startTime - auctionDetails.duration;
        return new FusionOrder(settlementContract, {
            salt: BigInt(order.salt) >> 160n,
            maker: new limit_order_sdk_1.Address(order.maker),
            receiver: new limit_order_sdk_1.Address(order.receiver),
            makerAsset: new limit_order_sdk_1.Address(order.makerAsset),
            takerAsset: new limit_order_sdk_1.Address(order.takerAsset),
            makingAmount: BigInt(order.makingAmount),
            takingAmount: BigInt(order.takingAmount)
        }, auctionDetails, postInteractionData, {
            allowMultipleFills: makerTraits.isMultipleFillsAllowed(),
            allowPartialFills: makerTraits.isPartialFillAllowed(),
            enablePermit2: makerTraits.isPermit2(),
            nonce: makerTraits.nonceOrEpoch(),
            permit: extension.makerPermit === constants_1.ZX
                ? undefined
                : extension.makerPermit,
            unwrapWETH: makerTraits.isNativeUnwrapEnabled(),
            orderExpirationDelay
        });
    }
    build() {
        return this.inner.build();
    }
    getOrderHash(domain = (0, limit_order_sdk_1.getLimitOrderV4Domain)(1)) {
        return this.inner.getOrderHash(domain);
    }
    getTypedData(domain = (0, limit_order_sdk_1.getLimitOrderV4Domain)(1)) {
        return this.inner.getTypedData(domain);
    }
    getCalculator() {
        return auction_calculator_1.AuctionCalculator.fromAuctionData(this.fusionExtension.postInteractionData, this.fusionExtension.details);
    }
}
exports.FusionOrder = FusionOrder;
FusionOrder.defaultExtra = {
    allowPartialFills: true,
    allowMultipleFills: true,
    unwrapWETH: false,
    enablePermit2: false,
    orderExpirationDelay: 12n
};
//# sourceMappingURL=fusion-order.js.map