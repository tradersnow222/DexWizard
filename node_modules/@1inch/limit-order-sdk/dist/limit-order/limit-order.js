"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrder = void 0;
const ethers_1 = require("ethers");
const byte_utils_1 = require("@1inch/byte-utils");
const assert_1 = __importDefault(require("assert"));
const eip712_1 = require("./eip712");
const maker_traits_1 = require("./maker-traits");
const extension_1 = require("./extension");
const address_1 = require("../address");
class LimitOrder {
    constructor(orderInfo, makerTraits = new maker_traits_1.MakerTraits(0n), extension = extension_1.Extension.default()) {
        this.extension = extension;
        this.makerAsset = orderInfo.makerAsset;
        this.takerAsset = orderInfo.takerAsset;
        this.makingAmount = orderInfo.makingAmount;
        this.takingAmount = orderInfo.takingAmount;
        this.salt = orderInfo.salt || LimitOrder.buildSalt(extension);
        this.maker = orderInfo.maker;
        this.receiver = orderInfo.receiver || address_1.Address.ZERO_ADDRESS;
        this.makerTraits = makerTraits;
        if (!extension.isEmpty()) {
            this.makerTraits.withExtension();
        }
    }
    static buildSalt(extension, baseSalt = BigInt(Math.round(Math.random() * Date.now()))) {
        if (extension.isEmpty()) {
            return baseSalt;
        }
        return (baseSalt << 160n) | (extension.keccak256() & byte_utils_1.UINT_160_MAX);
    }
    static fromCalldata(bytes) {
        (0, assert_1.default)((0, byte_utils_1.isHexString)(bytes), 'Bytes should be valid hex string with 0x prefix');
        const info = ethers_1.AbiCoder.defaultAbiCoder().decode([LimitOrder.Web3Type], bytes);
        const order = info[0];
        return new LimitOrder({
            salt: order.salt && BigInt(order.salt),
            maker: new address_1.Address(order.maker),
            receiver: new address_1.Address(order.receiver),
            takingAmount: BigInt(order.takingAmount),
            makingAmount: BigInt(order.makingAmount),
            takerAsset: new address_1.Address(order.takerAsset),
            makerAsset: new address_1.Address(order.makerAsset)
        }, new maker_traits_1.MakerTraits(BigInt(order.makerTraits)));
    }
    toCalldata() {
        return ethers_1.AbiCoder.defaultAbiCoder().encode([LimitOrder.Web3Type], [this.build()]);
    }
    build() {
        return {
            maker: this.maker.toString(),
            makerAsset: this.makerAsset.toString(),
            takerAsset: this.takerAsset.toString(),
            makerTraits: (this.makerTraits?.asBigInt() || 0n).toString(),
            salt: this.salt.toString(),
            makingAmount: this.makingAmount.toString(),
            takingAmount: this.takingAmount.toString(),
            receiver: this.receiver.toString()
        };
    }
    getTypedData(domain = (0, eip712_1.getLimitOrderV4Domain)(1)) {
        return (0, eip712_1.buildOrderTypedData)(domain.chainId, domain.verifyingContract, domain.name, domain.version, this.build());
    }
    getOrderHash(domain = (0, eip712_1.getLimitOrderV4Domain)(1)) {
        return (0, eip712_1.getOrderHash)(this.getTypedData(domain));
    }
}
exports.LimitOrder = LimitOrder;
LimitOrder.Web3Type = `tuple(${[
    'uint256 salt',
    'address maker',
    'address receiver',
    'address makerAsset',
    'address takerAsset',
    'uint256 makingAmount',
    'uint256 takingAmount',
    'uint256 makerTraits'
]})`;
//# sourceMappingURL=limit-order.js.map